(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{657:function(s,t,a){"use strict";a.r(t);var n=a(88),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[s._v("#")]),s._v(" JavaScript")]),s._v(" "),a("blockquote",[a("p",[s._v("JavaScript ( JS ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。")])]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("名称")]),s._v(" "),a("th",[s._v("介绍")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("ECMAScript")]),s._v(" "),a("td",[s._v("是Javascript基础规范，定义了Javascript基础语法。")])]),s._v(" "),a("tr",[a("td",[s._v("BOM 浏览器对象模型")]),s._v(" "),a("td",[s._v("可以对浏览器窗口进行访问和操作。")])]),s._v(" "),a("tr",[a("td",[s._v("DOM 文档对象模型")]),s._v(" "),a("td",[s._v("通过创建树来表示文档，从而使开发者对文档的内容和结构具有控制力。用 DOM API 可以轻松操作文档。")])])])]),s._v(" "),a("h2",{attrs:{id:"冷门小知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冷门小知识"}},[s._v("#")]),s._v(" 冷门小知识")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("奇怪的小现象"),a("br"),s._v(" "),a("img",{attrs:{src:"/assets/img/js1.jpg",width:"300",height:"auto",align:"middle"}})])]),s._v(" "),a("li",[a("p",[s._v("JS运行原理（引擎编译的过程）")]),s._v(" "),a("ul",[a("li",[s._v("首先将JS源码通过解析器解析成抽象语法处AST")]),s._v(" "),a("li",[s._v("在通过解释器将AST编译成字节码bytecode")]),s._v(" "),a("li",[s._v("字节码最后通过编译器生成机器代码（根据不同平台生成不同的）")]),s._v(" "),a("li",[s._v("因为JS是动态类型的语言，变量类型不固定，所以如果我们频繁的变化变量类型，会对V8引擎造成困惑，造成一定程度的性能影响，所以尽量不要随意更换变量类型")])])]),s._v(" "),a("li",[a("p",[s._v("箭头函数不写{} 相当于 {return  ***}")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    let Router = [\n        {\n            id:1,\n            pid:0,\n            name:'father1',\n            path:'/father1'\n        },\n        {\n            id:2,\n            pid:1,\n            name:'children1',\n            path:'/children1'\n        }]\n\n    let parents1 = data.filter(a=>a.pid===0);    //正确\n    let parents2 = data.filter(a=>{a.pid===0});  //错误\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("h2",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[s._v("#")]),s._v(" 特点")]),s._v(" "),a("ol",[a("li",[s._v("弱类型\nJavaScript是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。")]),s._v(" "),a("li",[s._v("解释型(解释型或即时编译型)")]),s._v(" "),a("li",[s._v("基于对象\njs种所有数据根源上都是对象")]),s._v(" "),a("li",[s._v("事件驱动")]),s._v(" "),a("li",[s._v("单线程/异步(callback)")])]),s._v(" "),a("h2",{attrs:{id:"内存回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存回收机制"}},[s._v("#")]),s._v(" 内存回收机制")]),s._v(" "),a("ul",[a("li",[s._v("回收时机：内存快满的时候。")]),s._v(" "),a("li",[s._v("回收机制：全局变量不回收，局部变量失去引用的时候回收。")]),s._v(" "),a("li",[s._v("当内存使用快满的时候，JS就会去内存里找有没有可以回收的局部变量，有就回收。无则继续执行，直到内存溢出报错。")]),s._v(" "),a("li",[s._v("所以我们在编写代码的时候，如果有特别大的全局变量，在使用完毕之后一定记得释放内存(让变量=null||undefined)。")])]),s._v(" "),a("h2",{attrs:{id:"特别注意的点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特别注意的点"}},[s._v("#")]),s._v(" 特别注意的点")]),s._v(" "),a("ul",[a("li",[s._v("Promise接收的回调是同步的，只有then，catch里的才是异步")]),s._v(" "),a("li",[a("strong",[s._v("异步任务队列里的宏任务要执行的时候，必须确保队列里的微任务清空才可")])]),s._v(" "),a("li",[s._v("alert出来的结果都要经过toStrng处理，即都是字符串")]),s._v(" "),a("li",[s._v("除了函数内部的var是局部的，剩下的var都是全局的")])]),s._v(" "),a("h2",{attrs:{id:"event-loop-主线程-、微任务、宏任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-主线程-、微任务、宏任务"}},[s._v("#")]),s._v(" Event Loop（主线程）、微任务、宏任务")]),s._v(" "),a("img",{attrs:{src:"/assets/img/jsOrder.jpg",width:"600",height:"auto",align:"middle"}}),s._v(" "),a("ul",[a("li",[a("p",[s._v("Event Loop由调用栈、消息队列（宏任务）和微任务队列组成")]),s._v(" "),a("ol",[a("li",[s._v("从全局代码开始，一行一行执行，如果执行错误则停止后面的代码执行。")]),s._v(" "),a("li",[s._v("遇到函数就压入调用栈中，执行里面的代码，执行完毕就弹出调用栈")]),s._v(" "),a("li",[s._v("JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。")]),s._v(" "),a("li",[s._v("消息队列中的代码会在调用栈和微任务队列清空的时候执行")])])]),s._v(" "),a("li",[a("p",[s._v("执行顺序")]),s._v(" "),a("ol",[a("li",[s._v("调用栈空闲的时候，如果有微任务就先执行微任务")]),s._v(" "),a("li",[s._v("接着浏览器会尝试进行DOM渲染，渲染完之后才会触发Event loop执行消息队列（宏任务）中的代码")]),s._v(" "),a("li",[s._v("宏任务中的代码被压入调用栈中")])])]),s._v(" "),a("li",[a("p",[s._v("微任务（DOM渲染之前完成，都是ES6的API）"),a("br"),s._v("\nPromise process.nextTick  async/await")])]),s._v(" "),a("li",[a("p",[s._v("宏任务（DOM渲染之后完成，都是浏览器的API）"),a("br"),s._v("\n整体代码script setTimeout setInterval  Ajax DOM事件")])])]),s._v(" "),a("h3",{attrs:{id:"牛刀小试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#牛刀小试"}},[s._v("#")]),s._v(" 牛刀小试")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("        console.log(1)                          \n        setTimeout(() => {                     \n            console.log('set1')\n            new Promise((reslove, reject) => {\n                console.log('pro1')\n                reslove()\n            }).then(() => {\n                console.log('then1')\n            })\n        })\n\n        setTimeout(() => {                     \n            console.log('set2')\n        })\n\n        new Promise((reslove) => {              \n            console.log('pro2')\n            reslove()\n        }).then(() => {\n            console.log('then2')\n        })\n\n        console.log(2)\n        /*\n        1. 输出1 \n        2. 遇到setTimeOut都放到异步执行队列\n        3. 输出pro2，then2被放入异步执行队列\n        4. 输出2\n        5. 此时异步队列里有set1，set2和then2,因为then2是微任务，setTimeOut是宏任务，所以先输出then2\n        6. 接着执行set1输出set1，再输出pro1，then1被放入异步执行队列\n        7. 异步队列只剩then1和set2，因为then1是微任务，要执行set2则必须先执行then1,所以先输出then1，在输出set2\n\n        1   pro2  2  then2  set1 pro1 then1 set2\n        */\n\n        //做这一类面试题的时候，最好在纸上列出异步任务队列，写清楚微任务宏任务，便一目了然\n        //第一轮执行完毕后：{微任务:[then2]   宏任务:[set1,set2]}\n        //第二轮执行完毕后：{微任务:[then1]   宏任务:[set2]}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br")])]),a("h2",{attrs:{id:"js预解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js预解析"}},[s._v("#")]),s._v(" JS预解析")]),s._v(" "),a("h2",{attrs:{id:"js内存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js内存机制"}},[s._v("#")]),s._v(" JS内存机制")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("知识储备")]),s._v(" "),a("ol",[a("li",[s._v("JS有三种数据类型，基本类型(number,boolean,string,null,undefined)和引用类型(function,object)特殊类型(symbol)")]),s._v(" "),a("li",[s._v("内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动”释放。后者被称为垃圾回收")]),s._v(" "),a("li",[s._v("JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈提供代码运行的环境，存放基础类型，堆存放引用类型，池存放常量。")])])]),s._v(" "),a("h3",{attrs:{id:"了解内存空间的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#了解内存空间的优点"}},[s._v("#")]),s._v(" 了解内存空间的优点")]),s._v(" "),a("ul",[a("li",[s._v("了解浅拷贝与深拷贝有什么不同")]),s._v(" "),a("li",[s._v("对闭包、原型有更好的理解")]),s._v(" "),a("li",[s._v("对于引用数据类型、初始数据类型有更好的理解")])]),s._v(" "),a("h3",{attrs:{id:"基础数据类型与栈区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础数据类型与栈区"}},[s._v("#")]),s._v(" 基础数据类型与栈区")]),s._v(" "),a("ul",[a("li",[s._v("JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问")]),s._v(" "),a("li",[s._v("栈空间的特点 先进后出，后进先出。")]),s._v(" "),a("li",[s._v("栈内存就是给代码的执行提供一个环境，也叫上下文，它的大小是固定的（存在栈内存溢出的情况）")])]),s._v(" "),a("h3",{attrs:{id:"引用数据类型与堆区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型与堆区"}},[s._v("#")]),s._v(" 引用数据类型与堆区")]),s._v(" "),a("ul",[a("li",[s._v("堆内存是用来存储引用类型值的，比如对象、数组等，它的大小不固定")]),s._v(" "),a("li",[s._v("JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。")])]),s._v(" "),a("ul",[a("li",[s._v("如何去操作对象")])]),s._v(" "),a("ul",[a("li",[s._v("在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。")])]),s._v(" "),a("ul",[a("li",[s._v("我们的堆区存取数据的方式与书架很类似")])]),s._v(" "),a("ul",[a("li",[a("p",[s._v("书虽然也是有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的属性(key)是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。")])]),s._v(" "),a("li",[a("p",[s._v("可以看到，在上面的图中，我们的变量都存在栈区，但是如果变量所对应的是一个对象或者数组，那么它所保存的其实是他们在堆区中的一个地址的指针。")])]),s._v(" "),a("li",[a("p",[s._v("那么当我们要访问存在于堆区中的内容的时候，首先需要在栈区中获取到这个对象的地址的引用(保存地址的变量)，然后再从堆内存中取得我们需要的数据。")])])]),s._v(" "),a("p",[s._v("上图中的变量是在栈区保存的，那么当栈区中的数据发生拷贝行为的时候，系统会自动为新的变量开辟一个房间，并赋一个新的值，所以在拷贝后，再修改新的变量不会对原来的变量值造成影响。")]),s._v(" "),a("p",[s._v("在demo2中我们发现我们是在拷贝一个对象(引用数据类型)。而引用数据类型的拷贝也会为它新开辟一个变量的栈区内存，但不同的是，这个新的变量只会保存原来引用类型的一个地址指针。当指针相同的时候，尽管他们不是同一个变量，但是更改其中一个，另外一个也会受到影响。")])])}),[],!1,null,null,null);t.default=e.exports}}]);