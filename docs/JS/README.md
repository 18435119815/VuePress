# JavaScript
> JavaScript ( JS ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。

|名称|介绍|
|--	|--	|
|ECMAScript|是Javascript基础规范，定义了Javascript基础语法。|
|BOM 浏览器对象模型|可以对浏览器窗口进行访问和操作。|
|DOM 文档对象模型|通过创建树来表示文档，从而使开发者对文档的内容和结构具有控制力。用 DOM API 可以轻松操作文档。|

## 冷门小知识
1.  奇怪的小现象  
<img src="/assets/img/js1.jpg" width="300" height="auto" align="middle" />    

2.  JS运行原理（引擎编译的过程）
    - 首先将JS源码通过解析器解析成抽象语法处AST
    - 在通过解释器将AST编译成字节码bytecode
    - 字节码最后通过编译器生成机器代码（根据不同平台生成不同的）
    - 因为JS是动态类型的语言，变量类型不固定，所以如果我们频繁的变化变量类型，会对V8引擎造成困惑，造成一定程度的性能影响，所以尽量不要随意更换变量类型
3.  箭头函数不写{} 相当于 {return  ***}
```
    let Router = [
        {
            id:1,
            pid:0,
            name:'father1',
            path:'/father1'
        },
        {
            id:2,
            pid:1,
            name:'children1',
            path:'/children1'
        }]

    let parents1 = data.filter(a=>a.pid===0);    //正确
    let parents2 = data.filter(a=>{a.pid===0});  //错误
```



## 特点
1.  弱类型
    JavaScript是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。
2.  解释型(解释型或即时编译型)
3.  基于对象
    js种所有数据根源上都是对象
4.  事件驱动
5.  单线程/异步(callback)

  

## 内存回收机制
- 回收时机：内存快满的时候。
- 回收机制：全局变量不回收，局部变量失去引用的时候回收。  
- 当内存使用快满的时候，JS就会去内存里找有没有可以回收的局部变量，有就回收。无则继续执行，直到内存溢出报错。
- 所以我们在编写代码的时候，如果有特别大的全局变量，在使用完毕之后一定记得释放内存(让变量=null||undefined)。


## 特别注意的点
- Promise接收的回调是同步的，只有then，catch里的才是异步
- **异步任务队列里的宏任务要执行的时候，必须确保队列里的微任务清空才可**
- alert出来的结果都要经过toStrng处理，即都是字符串
- 除了函数内部的var是局部的，剩下的var都是全局的

## Event Loop（主线程）、微任务、宏任务
<img src="/assets/img/jsOrder.jpg" width="600" height="auto" align="middle" />

- Event Loop由调用栈、消息队列（宏任务）和微任务队列组成
    1.  从全局代码开始，一行一行执行，如果执行错误则停止后面的代码执行。  
    2.  遇到函数就压入调用栈中，执行里面的代码，执行完毕就弹出调用栈
    3.  JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。
    4.  消息队列中的代码会在调用栈和微任务队列清空的时候执行
- 执行顺序
    1.  调用栈空闲的时候，如果有微任务就先执行微任务
    2.  接着浏览器会尝试进行DOM渲染，渲染完之后才会触发Event loop执行消息队列（宏任务）中的代码
    3.  宏任务中的代码被压入调用栈中
    
    



- 微任务（DOM渲染之前完成，都是ES6的API）    
Promise process.nextTick  async/await
- 宏任务（DOM渲染之后完成，都是浏览器的API）  
整体代码script setTimeout setInterval  Ajax DOM事件

### 牛刀小试
```
        console.log(1)                          
        setTimeout(() => {                     
            console.log('set1')
            new Promise((reslove, reject) => {
                console.log('pro1')
                reslove()
            }).then(() => {
                console.log('then1')
            })
        })

        setTimeout(() => {                     
            console.log('set2')
        })

        new Promise((reslove) => {              
            console.log('pro2')
            reslove()
        }).then(() => {
            console.log('then2')
        })

        console.log(2)
        /*
        1. 输出1 
        2. 遇到setTimeOut都放到异步执行队列
        3. 输出pro2，then2被放入异步执行队列
        4. 输出2
        5. 此时异步队列里有set1，set2和then2,因为then2是微任务，setTimeOut是宏任务，所以先输出then2
        6. 接着执行set1输出set1，再输出pro1，then1被放入异步执行队列
        7. 异步队列只剩then1和set2，因为then1是微任务，要执行set2则必须先执行then1,所以先输出then1，在输出set2

        1   pro2  2  then2  set1 pro1 then1 set2
        */

        //做这一类面试题的时候，最好在纸上列出异步任务队列，写清楚微任务宏任务，便一目了然
        //第一轮执行完毕后：{微任务:[then2]   宏任务:[set1,set2]}
        //第二轮执行完毕后：{微任务:[then1]   宏任务:[set2]}
```


## JS预解析




## JS内存机制

::: tip 知识储备
1.  JS有三种数据类型，基本类型(number,boolean,string,null,undefined)和引用类型(function,object)特殊类型(symbol)
2.  内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动”释放。后者被称为垃圾回收
3.  JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈提供代码运行的环境，存放基础类型，堆存放引用类型，池存放常量。
:::

### 了解内存空间的优点

* 了解浅拷贝与深拷贝有什么不同
* 对闭包、原型有更好的理解
* 对于引用数据类型、初始数据类型有更好的理解


### 基础数据类型与栈区

- JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问
- 栈空间的特点 先进后出，后进先出。
- 栈内存就是给代码的执行提供一个环境，也叫上下文，它的大小是固定的（存在栈内存溢出的情况）

### 引用数据类型与堆区
- 堆内存是用来存储引用类型值的，比如对象、数组等，它的大小不固定
- JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。

* 如何去操作对象
- 在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。 

* 我们的堆区存取数据的方式与书架很类似
- 书虽然也是有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的属性(key)是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。



- 可以看到，在上面的图中，我们的变量都存在栈区，但是如果变量所对应的是一个对象或者数组，那么它所保存的其实是他们在堆区中的一个地址的指针。



- 那么当我们要访问存在于堆区中的内容的时候，首先需要在栈区中获取到这个对象的地址的引用(保存地址的变量)，然后再从堆内存中取得我们需要的数据。




 上图中的变量是在栈区保存的，那么当栈区中的数据发生拷贝行为的时候，系统会自动为新的变量开辟一个房间，并赋一个新的值，所以在拷贝后，再修改新的变量不会对原来的变量值造成影响。






在demo2中我们发现我们是在拷贝一个对象(引用数据类型)。而引用数据类型的拷贝也会为它新开辟一个变量的栈区内存，但不同的是，这个新的变量只会保存原来引用类型的一个地址指针。当指针相同的时候，尽管他们不是同一个变量，但是更改其中一个，另外一个也会受到影响。


