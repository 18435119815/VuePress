# JavaScript
> JavaScript ( JS ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。

|名称|介绍|
|--	|--	|
|ECMAScript|是Javascript基础规范，定义了Javascript基础语法。|
|BOM 浏览器对象模型|可以对浏览器窗口进行访问和操作。|
|DOM 文档对象模型|通过创建树来表示文档，从而使开发者对文档的内容和结构具有控制力。用 DOM API 可以轻松操作文档。|

## 冷门小知识
1.  

## 特点
1.  弱类型
    JavaScript是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。
2.  解释型(解释型或即时编译型)
3.  基于对象
    js种所有数据根源上都是对象
4.  事件驱动
5.  单线程/异步(callback)

## JS执行顺序
<img src="/assets/img/jsOrder.jpg" width="600" height="auto" align="middle" />  

## 内存回收机制
- 回收时机：内存快满的时候。
- 回收机制：全局变量不回收，局部变量失去引用的时候回收。  
- 当内存使用快满的时候，JS就会去内存里找有没有可以回收的局部变量，有就回收。无则继续执行，直到内存溢出报错。
- 所以我们在编写代码的时候，如果有特别大的全局变量，在使用完毕之后一定记得释放内存(让变量=null||undefined)。


## 特别注意的点
- Promise接收的回调是同步的，只有then，catch里的才是异步
- **异步任务队列里的宏任务要执行的时候，必须确保队列里的微任务清空才可**

## 微任务宏任务
- 微任务    
Promise process.nextTick
- 宏任务  
整体代码script setTimeout setInterval

### 牛刀小试
```
        console.log(1)                          
        setTimeout(() => {                     
            console.log('set1')
            new Promise((reslove, reject) => {
                console.log('pro1')
                reslove()
            }).then(() => {
                console.log('then1')
            })
        })

        setTimeout(() => {                     
            console.log('set2')
        })

        new Promise((reslove) => {              
            console.log('pro2')
            reslove()
        }).then(() => {
            console.log('then2')
        })

        console.log(2)
        /*
        1. 输出1 
        2. 遇到setTimeOut都放到异步执行队列
        3. 输出pro2，then2被放入异步执行队列
        4. 输出2
        5. 此时异步队列里有set1，set2和then2,因为then2是微任务，setTimeOut是宏任务，所以先输出then2
        6. 接着执行set1输出set1，再输出pro1，then1被放入异步执行队列
        7. 异步队列只剩then1和set2，因为then1是微任务，要执行set2则必须先执行then1,所以先输出then1，在输出set2

        1   pro2  2  then2  set1 pro1 then1 set2
        */

        //做这一类面试题的时候，最好在纸上列出异步任务队列，写清楚微任务宏任务，便一目了然
        //第一轮执行完毕后：{微任务:[then2]   宏任务:[set1,set2]}
        //第二轮执行完毕后：{微任务:[then1]   宏任务:[set2]}
```

## JS内存机制
> 内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动”释放。后者被称为垃圾回收

### 了解内存空间的优点

* 了解浅拷贝与深拷贝有什么不同
* 对闭包、原型有更好的理解
* 对于引用数据类型、初始数据类型有更好的理解

### JS内存模型

> JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

### 基础数据类型与栈区

> JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问 数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。就类似于乒乓球盒子



> 这种乒乓球的存放方式与栈区中存取数据的方式是一样的。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。

### 引用数据类型与堆区

> JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。

* 如何去操作对象
> 在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。 

* 我们的堆区存取数据的方式与书架很类似
> 书虽然也是有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的属性(key)是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。



> 可以看到，在上面的图中，我们的变量都存在栈区，但是如果变量所对应的是一个对象或者数组，那么它所保存的其实是他们在堆区中的一个地址的指针。



> 那么当我们要访问存在于堆区中的内容的时候，首先需要在栈区中获取到这个对象的地址的引用(保存地址的变量)，然后再从堆内存中取得我们需要的数据。




 上图中的变量是在栈区保存的，那么当栈区中的数据发生拷贝行为的时候，系统会自动为新的变量开辟一个房间，并赋一个新的值，所以在拷贝后，再修改新的变量不会对原来的变量值造成影响。






在demo2中我们发现我们是在拷贝一个对象(引用数据类型)。而引用数据类型的拷贝也会为它新开辟一个变量的栈区内存，但不同的是，这个新的变量只会保存原来引用类型的一个地址指针。当指针相同的时候，尽管他们不是同一个变量，但是更改其中一个，另外一个也会受到影响。


